为什么你有些代码没有发送？
我现在需要api/main.py、api/routers/logs.py、api/routers/status.py、services/log_streamer.py的详细完整代码，然后我期望可以加入一个功能，寻找当前所有的任务和任务状态，如是否正在执行，是否在排队。然后加入停止、删除任务的功能。


我的目标是在兼容目前测试脚本可以使用原有方式本地命令行运行的基础上，添加通过 FastAPI 提供全面的 REST API 支持，目前暂时完全不考虑任何安全设置，使用HTTP，我开发的目标是一个单线程非异步的API调用，后续调用应该进入队列排队，不允许使用docker部署，应该是直接使用命令行在本地运行。
我主机IP是100.64.0.5 端口你可以使用4150-4200之间的任意端口，这两者建议作为参数在代码中配置部分定义。
我不需要你详细的语言介绍，我希望所有的重点都在代码、代码说明、描述、注释中，代码中所有内容必须是专业的英文，除非特殊情况、意义为不是代码的内容需要特殊说明可以使用中文，之前你注释中的中文不需要改了。

请根据开发需求说明书中的介绍和要求，和我提供的代码，提供给我可以实现我需求的全部完整代码，谢谢。




## 一、需求专业描述

### 高度模块化与功能解耦需求描述

需求背景：
在现代软件开发中，系统的可维护性、可扩展性和灵活性对于应对不断变化的需求至关重要。为了实现这些目标，系统架构需要具备高度模块化和功能解耦的特性，以确保各个组件能够独立开发、测试、部署和维护，而不会相互影响。

需求描述：
构建一个高度模块化的测试管理系统，通过 FastAPI 提供全面的 REST API 支持，使各个功能模块之间实现松耦合、独立运行。系统应具备以下特性：

1. 模块独立性：各功能模块（如 CPU 检查、带宽测试、延迟测试等）应独立实现，彼此之间无直接依赖，通过明确定义的接口进行交互。
2. 接口驱动：系统通过标准化的 REST API 提供服务，允许外部系统或用户通过 HTTP 请求触发测试、获取结果和日志。
3. 可扩展性：新功能模块可以在不影响现有模块的情况下轻松添加，系统整体架构支持水平扩展。
4. 可维护性：代码结构清晰，遵循单一职责原则，每个模块仅负责特定的功能，便于定位和修复问题。
5. 异步处理：支持并发执行测试任务，确保 API 响应性能和系统的高可用性。
6. 监控与日志：集中化的日志管理，通过 API 提供日志获取与实时日志流功能，方便监控系统运行状态。

## 二、模块化编程规范手册

以下是针对您需求的 Python 项目模块化设计与实现的规范手册，涵盖目录结构、模块划分、接口设计、依赖管理、异常处理、日志管理等方面。

### 1. 目录结构设计

一个清晰的目录结构有助于维护和扩展。以下是推荐的项目目录结构：

```
QAtest/
├── api/
│   ├── __init__.py
│   ├── main.py
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── tests.py
│   │   ├── logs.py
│   │   └── status.py
│   ├── dependencies.py
│   └── schemas.py
├── modules/
│   ├── __init__.py
│   ├── cpu_check.py
│   ├── bandwidth_test.py
│   ├── latency_test.py
│   ├── reboot_test.py
│   ├── vcpu_check.py
│   ├── vm_control.py
│   ├── utils.py
│   ├── excel_handler.py
│   └── error_handler.py
├── services/
│   ├── __init__.py
│   ├── test_manager.py
│   ├── task_manager.py
│   └── log_streamer.py
├── config/
│   ├── __init__.py
│   └── config.py
├── logs/
│   └── test.log
├── tests/
│   ├── __init__.py
│   └── test_modules.py
├── requirements.txt
└── README.md
```

### 2. 模块划分与职责

#### a. API 层 (`api/`)
负责处理 HTTP 请求，提供 REST API 端点，与服务层交互以完成具体业务逻辑。

- main.py：FastAPI 应用实例的创建与配置，包含启动参数。
- routers/：按功能划分的路由模块，如 `tests.py` 处理测试相关的 API，`logs.py` 处理日志相关的 API，`status.py` 处理任务状态查询等。
- dependencies.py：定义 API 路由所需的依赖项，如数据库连接、认证（若需）。
- schemas.py：定义 API 请求与响应的数据模型，使用 Pydantic 进行数据验证。

#### b. 业务逻辑层 (`services/`)
处理核心业务逻辑，独立于 API 层和其他模块，确保业务逻辑的可复用性和独立性。

- test_manager.py：管理和协调不同测试模块的执行，处理任务的生命周期。
- task_manager.py：管理测试任务的调度、状态跟踪和结果存储。
- log_streamer.py：处理日志的实时流式传输，支持通过 API 实时获取日志。

#### c. 功能模块层 (`modules/`)
各功能独立模块，负责具体的测试操作和相关功能。

- 各功能模块文件（如 `cpu_check.py`、`bandwidth_test.py` 等）：封装具体的测试逻辑，遵循单一职责原则。
- utils.py：通用工具函数，供各模块调用。
- excel_handler.py：处理 Excel 文件的读写操作。
- error_handler.py：定义自定义异常类，用于统一的错误处理。

#### d. 配置层 (`config/`)
集中管理配置参数，确保配置的统一性和可维护性。

- config.py：使用 `Config` 类管理所有配置参数，支持从文件加载与环境变量配置。

#### e. 日志管理层 (`logs/`)
集中存储和管理日志文件，为日志的获取和流式传输做准备。

#### f. 测试层 (`tests/`)
包含单元测试与集成测试，确保各模块功能的正确性和稳定性。

### 3. 接口设计

#### a. API 端点设计
确保 API 端点遵循 RESTful 设计原则，使用明确的资源路径和 HTTP 方法。

- 启动测试任务
  - 方法：`POST`
  - 路径：`/api/tests/start`
  - 功能：接收测试请求，启动相应的测试任务。
  - 请求体：包含测试类型、参数等。
  - 响应：任务 ID 与启动状态。

- 查询测试任务状态
  - 方法：`GET`
  - 路径：`/api/tests/status/{task_id}`
  - 功能：返回指定任务的当前状态。
  - 响应：任务状态信息（进行中、完成、失败等）。

- 获取测试结果
  - 方法：`GET`
  - 路径：`/api/tests/results/{task_id}`
  - 功能：提供指定任务的测试结果下载或数据展示。
  - 响应：结果文件下载链接或 JSON 格式的结果数据。

- 获取日志文件
  - 方法：`GET`
  - 路径：`/api/logs/download`
  - 功能：提供日志文件的下载。
  - 响应：日志文件内容或下载链接。

- 实时获取日志
  - 方法：`GET`
  - 路径：`/api/logs/stream`
  - 功能：通过 WebSocket 或 SSE 实现实时日志流。
  - 响应：持续的日志数据流。

#### b. 数据模型设计
使用 Pydantic 定义请求与响应的数据格式，确保数据的有效性和一致性。

- Request Schemas：定义启动测试所需的参数，如测试类型、设备信息等。
- Response Schemas：定义任务 ID、状态信息、结果数据等。

### 4. 服务与任务管理

#### a. 任务调度
由于测试任务可能需要长时间运行，需采用异步处理或后台任务管理机制。

- 异步执行：使用 `asyncio` 或背景任务（如 `FastAPI` 的 `BackgroundTasks`）执行测试，避免阻塞主线程。
- 任务队列：实现一个简单的任务队列管理器，跟踪任务的状态和结果。对于更复杂的需求，可以引入任务队列系统如 Celery。

#### b. 状态跟踪
为每个启动的测试任务分配唯一的任务 ID，并维护其状态（如等待、进行中、完成、失败）。

- 使用内存数据结构（如字典）或外部存储（如数据库）存储任务状态和结果。
- 提供 API 接口查询任务状态和获取结果。

### 5. 日志管理与实时日志流

#### a. 集中化日志配置
确保日志系统支持多个模块的日志记录，配置统一的日志格式和输出目的地。

- 在 `logger.py` 中配置日志记录器，使用 `logging` 模块的 `FileHandler` 和 `StreamHandler`。
- 为实时日志流添加自定义日志处理器，将日志发送到流管理模块。

#### b. 日志获取
通过 API 提供日志文件的下载和查看功能。

- 实现 `/api/logs/download` 端点，允许用户下载或查看日志文件内容。

#### c. 实时日志流
实现实时日志传输，使用户能够在测试运行时实时监控日志输出。

- 使用 Server-Sent Events (SSE)：
  - FastAPI 支持 SSE，可以通过生成器函数实时发送日志数据。
- 使用 WebSockets：
  - 实现一个 WebSocket 端点，客户端连接后接收实时日志推送。
- 日志处理器集成：
  - 在日志配置中添加一个自定义日志处理器，将日志消息发送到实时流管理服务。

### 6. 依赖管理与配置

#### a. 统一配置管理
集中管理所有系统配置，使用环境变量和配置文件支持不同环境的配置需求。

- 在 `config/config.py` 中使用 `pydantic` 的 `BaseSettings` 类，支持从环境变量和 YAML/JSON 配置文件加载配置参数。
- 包含 API 服务器配置、日志文件路径、测试参数等。

#### b. 依赖注入
利用 FastAPI 的依赖注入机制，为不同模块提供所需的依赖项。

- 在 `api/dependencies.py` 中定义依赖项，如测试管理器实例、日志管理器等。
- 在路由模块中通过依赖注入获取所需的服务实例。

### 7. 异常处理与错误管理

#### a. 统一异常处理
为 API 定义统一的异常处理机制，确保错误信息的一致性和友好性。

- 使用 FastAPI 的 `ExceptionHandler` 装饰器，捕获自定义异常并返回标准化的错误响应。
- 在 `error_handler.py` 中定义自定义异常类，并在服务层抛出这些异常。

#### b. 错误日志记录
在发生错误时，详细记录错误信息到日志文件，便于排查问题。


## 三、模块拆分实现建议

为了确保系统的高度模块化和解耦，以下是针对各功能的拆分建议：

### 1. 核心服务层 (`services/`)

#### a. TestManager
- 职责：协调和控制各个测试模块的执行，管理测试任务的生命周期。
- 实现方式：独立的类，提供启动、停止、查询状态等方法。

#### b. TaskManager
- 职责：管理测试任务的调度、存储任务状态和结果。
- 实现方式：使用线程池或异步任务队列，确保任务的独立执行与并发处理。

#### c. LogStreamer
- 职责：实时捕获日志并通过 WebSocket 或 SSE 推送给客户端。
- 实现方式：独立类，集成到日志系统，使用异步生成器或事件驱动模型处理日志流。

### 2. 功能模块层 (`modules/`)

每个功能模块（如 `cpu_check.py`、`bandwidth_test.py` 等）应独立实现，不依赖于其他功能模块，通过明确定义的接口与 `TestManager` 或其他服务层交互。

- 单一职责：每个模块仅负责其特定的测试逻辑，避免跨模块调用或依赖。
- 接口定义：定义清晰的方法接口，供服务层调用，如 `run_test()`、`get_results()` 等。

### 3. API 层 (`api/`)

#### a. Routers
- 测试路由 (`routers/tests.py`)：处理测试任务的启动、状态查询、结果获取等。
- 日志路由 (`routers/logs.py`)：处理日志文件的下载和实时日志流的建立。
- 状态路由 (`routers/status.py`)：提供系统整体状态监控（如健康检查）。

#### b. Schemas
- 请求模型：定义启动测试所需的参数结构。
- 响应模型：定义 API 返回的数据格式，如任务 ID、状态信息、结果数据等。

### 4. 配置与依赖管理 (`config/` 和 `api/dependencies.py`)

- 配置模块 (`config/config.py`)：集中管理所有配置参数，通过环境变量和配置文件支持多环境部署。
- 依赖注入 (`api/dependencies.py`)：定义 API 路由所需的依赖项，如 `TestManager` 实例，确保各路由模块能无缝访问业务逻辑服务。

### 5. 日志管理与实时流 (`services/log_streamer.py`)

- 日志捕获：通过自定义日志处理器或订阅日志事件，捕获所有模块的日志输出。
- 实时传输：使用 WebSocket 或 SSE 技术，将捕获的日志实时推送给前端或客户端。

### 6. 异常处理与错误管理 (`modules/error_handler.py` 和 `api/main.py`)

- 自定义异常：在 `error_handler.py` 中定义业务相关的自定义异常类，统一管理错误类型。
- API 异常处理：在 `api/main.py` 中注册异常处理器，将自定义异常转换为标准化的 HTTP 错误响应。

## 四、总结

通过上述模块化编程规范手册，您可以将现有的命令行脚本转换为一个高度模块化、功能解耦且具备全面 REST API 支持的系统架构。关键在于以下几点：

1. 清晰的模块划分：将不同功能模块独立实现，确保各模块之间无直接依赖，通过接口进行交互。
2. 统一的配置与依赖管理：集中管理配置参数，使用依赖注入机制确保各模块可复用性与独立性。
3. 异步与并发处理：采用异步编程模式，支持高并发请求与长时间运行的任务执行。
4. 集中化日志管理：通过统一的日志系统实现日志的获取与实时流式传输，提升监控能力。
5. 全面的 API 设计：遵循 RESTful 设计原则，提供清晰、标准化的 API 端点，确保外部系统的易用性与集成性。
6. 严格的测试与质量保证：编写完善的测试套件，确保各模块的功能正确性与系统的稳定性。



### Python 代码设计与规范

#### 1. 高度模块化设计

1.1 全局变量与配置管理

- 集中定义：
  - 在代码开头统一定义所有全局变量和数据结构，如文件路径、仓库名称、日志配置等，确保代码的可维护性和扩展性。
  - 使用数据类（`@dataclass`）或配置文件（如JSON、YAML）管理全局配置，避免硬编码。

- 描述性命名：
  - 全局变量应具备描述性名称，避免使用模糊或过于简短的名称。
  - 数据结构的组织需符合逻辑关系，便于理解和使用。

1.2 类与功能模块

- 封装相关功能：
  - 使用类（`class`）封装相关功能模块，确保代码结构清晰，职责单一。
  - 每个类应负责特定功能，如构建管理、日志处理、命令执行等，提高代码的内聚性。

1.3 装饰器应用

- 优化代码逻辑：
  - 利用装饰器（`decorator`）处理重复性任务，如日志记录、时间测量等。
  - 装饰器需简洁明了，具备良好的可复用性，提升代码的可读性和维护性。

1.4 日志管理

- 独立日志文件：
  - 为所有编译命令的输出信息分别保存到独立的日志文件中，便于追踪和分析。
  
- 详细日志记录：
  - 日志应包含每个模块的执行时间和整体编译时间，确保对编译过程有全面的监控。

---

#### 2. 代码整洁与规范

2.1 代码排版

- 一致缩进：
  - 采用一致的缩进方式（推荐4个空格），合理分隔代码块，确保逻辑清晰。
  
- 适当行长：
  - 每行代码长度适中，避免过长，提升代码的可读性。

2.2 注释与文档

- 英文注释与Docstrings：
  - 为每个函数或方法添加详细的英文注释及Docstrings，说明其作用、参数、返回值及关键逻辑。
  
- 类型提示：
  - 使用类型提示（Type Hint）明确参数和返回值的类型，增强代码的可读性和静态分析能力。

2.3 命名规范

- 描述性命名：
  - 变量、函数、类等命名应具备描述性，采用驼峰命名法（CamelCase）或下划线命名法（snake_case），保持一致性。
  
- 避免模糊命名：
  - 避免使用过于简短或模糊的名称，确保命名能够准确反映其用途和意义。

---

#### 3. 错误处理与进度监控

3.1 错误处理机制

- 全面错误处理：
  - 实现全面的错误处理，提供明确且描述性的错误提示，帮助用户快速定位和解决问题。
  
- 稳定运行：
  - 确保脚本在异常情况下能够稳定运行，避免因未处理的异常导致程序崩溃。
  
- 格式化输出：
  - 使用图形化或格式化的输出方式，提升错误信息的可读性和美观性，确保错误信息在界面中突出显示。

3.2 进度监控与动态输出

- 实时状态显示：
  - 实时输出已完成和未完成的模块状态，提供直观的进度条和已完成模块数量提示，帮助用户了解执行进度。
  
- 准确性与实时性：
  - 进度监控应具备实时性和准确性，避免进度显示滞后或错误。

3.3 日志输出

- 多级别日志：
  - 实现不同级别的日志输出（如INFO、DEBUG、WARNING、ERROR），帮助开发者和用户快速定位问题。
  
- 详细日志内容：
  - 日志应包含时间戳、模块名称、日志级别和详细信息，确保日志的全面性和可追溯性。

---

#### 4. 减少代码重复

4.1 高级架构与数据结构

- 优化架构：
  - 采用高级编程架构和数据结构技术，减少代码冗余，提高代码的复用性。
  
- 数据封装：
  - 对于功能相似的变量和参数，使用数据封装和变量拼接优化，确保代码的模块化和复用性。

4.2 函数与方法复用

- 抽象重复逻辑：
  - 将重复出现的逻辑抽象为独立的函数或方法，避免在不同模块中重复编写相同的代码。
  
- 通用性与扩展性：
  - 确保复用的函数或方法具备良好的通用性和扩展性，适应不同场景的需求。

---

#### 5. 高级代码实践

5.1 复杂结构与稳定性

- 全面功能模块：
  - 编写结构复杂且全面的代码，确保各功能模块的正确性和稳定性。
  
- 使用高级特性：
  - 运用高级的Python特性和第三方库，如数据类（`@dataclass`）、异步编程（`asyncio`）等，提升代码性能。

5.2 主要使用Python

- 减少外部依赖：
  - 主要使用Python完成所有功能，尽量减少Bash等外部脚本的使用，确保跨平台兼容性和代码的可维护性。

5.3 可扩展性设计

- 未来扩展考虑：
  - 在设计功能实现时，考虑未来可能的扩展需求，确保代码结构具备良好的扩展性。
  
- 高度模块化与接口定义：
  - 通过高度复杂模块化设计和接口定义，便于后续功能的添加和修改，减少对现有代码的影响。