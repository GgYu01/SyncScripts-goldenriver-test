# 自动填写Release Note的Python脚本开发需求文档

## 1. 引言

本文档旨在详细描述一个用于在Linux环境下，使用Python 3.8.10编写的脚本，用于自动填写Release Note的Excel表格。该脚本应具备专业性、复杂性、高度模块化和丰富的可扩展性。本文档将为开发团队提供全面的需求和实现方法的描述。

## 2. 开发背景

在软件开发过程中，每次提交代码（commit）后，都需要更新Release Note的Excel表格。为了提高效率，避免手动操作的繁琐和可能的错误，需开发一个自动化脚本，实现以下功能：

- 基于已有的Excel表格，仅添加新内容，不修改之前的内容。
- 每次更新时，从第二行开始插入新行，确保最新内容位于第二行。
- 每行对应一个commit，若有多个commit，则使用相应数量的行进行描述。

## 3. 开发环境

- 操作系统：Linux
- 编程语言：Python 3.8.10

## 4. 脚本总体要求

1. **可维护性和可读性**：脚本需高度模块化，代码应清晰、易于维护。关键和复杂部分需要有专业的英文注释。

2. **参数设置**：涉及到可修改的参数和变量部分，不作为命令行参数，而是在源码中使用专门的数据结构供使用者修改。

3. **代码规范**：

   - 指定Python解释器，允许用户直接使用`*.py`执行脚本。
   - 指定编码格式。
   - 在代码开头添加详细的英文说明，包括用途和使用方法。

## 5. 详细功能需求

### 5.1 表格内容填写要求

表格需填写以下列：

1. **release 版本**
2. **功能**
3. **模块**
4. **压缩包/Patch**
5. **示例代码/文档路径**
6. **提交信息**
7. **测试负责人 / 修改人 / MTK owner**
8. **提交时间**
9. **是否向另外一个平台移植？**
10. **是否已经移植和测试？**
11. **是否Release客户及客户名**
12. **change ID / commit ID title**
13. **MTK合入日期**
14. **MTK注册情况**
15. **commit信息**

**注意**：未提及需求的列保持空白，供后续手动修改。

### 5.2 仓库路径和Tag命名规则

- 仓库路径：
  - `~/grpower`
  - `~/grt`
  - `~/grt_be`
  - `~/alps`及其子目录下的多个git仓库
  - `~/yocto`及其子目录下的多个git仓库
  - `~/grpower/workspace/nebula`及其子目录下的多个git仓库

- **排除路径**：`~/.repo`和`~/.jiri`及其所有子路径。

- **Tag命名规则**：

  - 对于`~/grpower/workspace/nebula`及其子目录下的git仓库：
    ```
    release-spm.mt8678_mt8676_<日期标识>
    ```
  - 对于其他git仓库：
    ```
    release-spm.mt8678_<日期标识>
    ```
  - **日期标识格式**：`YYYY_MMDD_NN`，例如`2024_1107_04`。

- **版本标识**：在所有仓库中应保持一致。

### 5.3 获取最新和次新的Tag

- **以`~/grt`仓库为例**：
  - 获取仓库中最新和次新的Tag的版本标识。
  - 基于该版本标识，拼接出适用于不同仓库的最新和次新的Tag。

### 5.4 判断提交和获取Patch路径

1. **判断提交**：

   - 在`~/grt`和`~/alps/vendor/mediatek/proprietary/trustzone/grt`仓库下，比较拼接构建出的最新和次新的Tag之间是否有提交（commit）。
   - 若有提交，检查commit信息中是否包含以下任意一个完全匹配的字符串：
     - `] thyp-sdk: `
     - `] nebula-sdk: `
     - `] tee: `

2. **生成Patch并获取路径**：

   - 使用以下命令生成Patch：
     ```
     git format-patch <次新的Tag>..<最新的Tag>
     ```
   - 判断哪个Patch对应上述特殊的提交信息。
   - 获取这些Patch的绝对路径，并去除路径中的`/home/nebula/`部分。

### 5.5 表格各列填写细则

#### 5.5.1 release 版本

- 填写内容：`~/grt`仓库下最新创建的Tag名称。

#### 5.5.2 功能

- 在以下路径及其所有子路径下的所有git仓库中，比较最新和次新的Tag之间是否有提交：
  - `~/grpower`
  - `~/grpower/workspace/nebula`
  - `~/alps`
  - `~/yocto`
  - `~/grt`
  - `~/grt_be`
- 若有提交，提取这些commit的message信息，取正文描述部分填入。

#### 5.5.3 模块

- 根据更新所在的路径填写对应的模块名称：

  - `~/grpower`或`~/grpower/workspace/nebula`：`nebula-hyper`
  - `~/alps`：`alps`
  - `~/yocto`：`yocto`
  - `~/grt`：`thyp-sdk`
  - `~/grt_be`：`thyp-sdk-be`

#### 5.5.4 压缩包/Patch

- **对于`~/grpower`、`~/grpower/workspace/nebula`仓库下的提交**：

  - 每个commit在此列中填入之前获取的包含特殊信息的Patch路径，去除`/home/nebula/`部分。
  - 例如：`alps/vendor/mediatek/proprietary/trustzone/grt/0003-<对应内容>.patch`
  - 若本行有多个Patch对应，在同一格内换行填入。

- **对于其他路径的更新**：

  - 在有更新的仓库下执行：
    ```
    git format-patch <次新的Tag>..<最新的Tag>
    ```
  - 获取每个commit对应的Patch文件的绝对路径，去除`/home/nebula/`部分，填入表格。
  - **注意**：每一行只能有一个commit及其对应的一个或多个Patch文件。

- **特殊处理**：确保表格内commit对应的Patch文件路径与`git format-patch`命令生成的排序和命名完全一致。

#### 5.5.5 提交信息

- 获取以下两个git仓库下的最后一个commit id：

  - `~/grpower/workspace/nebula/zircon`
  - `~/grpower/workspace/nebula/garnet`

- 填写格式：
  ```
  zircon: <zircon的commit id>
  garnet: <garnet的commit id>
  ```
- 在同一格内换行填入。

#### 5.5.6 测试负责人 / 修改人 / MTK owner

- **内容来源**：作为参数设置，优先使用命令行参数，若无则使用脚本代码中的默认值。
- **填写格式**：在同一格内，使用斜杠分隔。
  ```
  <测试负责人> / <修改人> / <MTK owner>
  ```
  例如：`高宇轩 / 武阳 / 金春阳`

#### 5.5.7 是否向另外一个平台移植？

- **内容来源**：作为参数设置，优先使用命令行参数，若无则使用脚本代码中的默认值。

#### 5.5.8 是否已经移植和测试？

- **内容来源**：作为参数设置，优先使用命令行参数，若无则使用脚本代码中的默认值。

#### 5.5.9 是否Release客户及客户名

- **内容来源**：作为参数设置，优先使用命令行参数，若无则使用脚本代码中的默认值。

#### 5.5.10 commit信息

- 填写本行commit所对应的commit id。

## 6. 实现方法

### 6.1 脚本结构设计

- **模块划分**：

  - **参数配置模块**：用于设置需要修改的参数和变量，使用专门、复杂的数据结构和配置类，方便使用者在源码中修改。
  - **Tag获取模块**：根据`~/grt`仓库获取最新和次新的Tag，并拼接生成其他仓库的Tag。
  - **提交判断模块**：判断各仓库在最新和次新的Tag之间是否有提交。
  - **Patch生成模块**：根据提交信息生成Patch，并获取Patch路径。
  - **表格更新模块**：按照要求将信息填入Excel表格，确保格式和内容的正确性。

### 6.2 参数设置

- **默认参数**：在脚本代码中定义默认值，包括：

  - 测试负责人
  - 修改人
  - MTK owner
  - 是否向另外一个平台移植
  - 是否已经移植和测试
  - 是否Release客户及客户名
  - 最新和次新的版本标识   此参数为供用户debug用

- **命令行参数**：优先使用命令行参数覆盖默认值。

### 6.3 处理流程

1. **获取最新和次新的Tag**：

   - 在`~/grt`仓库执行命令获取Tag列表，提取最新的两个Tag的版本标识。

2. **拼接其他仓库的Tag**：

   - 根据不同仓库的Tag命名规则，使用版本标识拼接生成其他仓库的最新和次新的Tag。

3. **判断各仓库的提交**：

   - 遍历指定的仓库路径，排除`.repo`和`.jiri`路径。
   - 比较各仓库最新和次新的Tag之间的提交记录。

4. **提取提交信息和Patch路径**：

   - 对于有提交的仓库，提取commit message的正文描述部分。
   - 根据特殊处理要求，生成Patch并获取路径，去除`/home/nebula/`部分。

5. **获取特定仓库的最后一个commit id**：

   - 在`~/grpower/workspace/nebula/zircon`和`~/grpower/workspace/nebula/garnet`仓库下，获取最后一个commit id。

6. **填充表格**：

   - 创建或打开已有的Excel表格。
   - 从第二行开始插入新行，确保最新内容位于第二行。
   - 按照填写细则，将各项信息填入对应的列中。

## 7. 注意事项

- **路径处理**：在获取Patch的绝对路径时，需注意去除`/home/nebula/`部分。

- **编码格式**：指定脚本的编码格式，确保读取和写入文件时不会出现编码问题。

- **异常处理**：在脚本中添加必要的异常处理，防止因意外情况导致脚本崩溃。

- **日志记录**：可在脚本中添加日志功能，记录脚本的运行状态，方便调试和维护。

### **Python 代码设计与规范**

#### 1. **模块化设计**

- **全局变量与数据结构**：
  - 在代码的开头统一定义所有全局变量和数据结构，包括文件路径、仓库名称、编译命令、日志配置、命令、配置参数、并发执行确保代码的可维护性和易于扩展。
  - 使用结构化的数据类（`dataclass`）或配置文件来组织和管理相关配置，确保配置的统一性和便于修改，避免硬编码，提高配置的灵活性和可变性。例如，所有需要用户提供的变量参数应作为数据结构的一部分集中定义，避免散布在代码的各个部分。

- **类的使用**：
  - 使用类（`class`）来封装相关的功能模块，确保代码结构清晰，职责单一，便于维护和扩展。
  - 每个类应负责特定的功能，如构建管理、日志处理、命令执行等，避免功能混杂，提升代码的内聚性。

- **装饰器的应用**：
  - 利用装饰器（`decorator`）优化代码逻辑，减少重复性任务，如日志记录、时间测量等。
  - 装饰器应简洁明了，具备良好的可复用性，提升代码的可读性和维护性。

- **日志管理**：
  - 所有编译命令的输出信息需要分别保存到独立的日志文件中，便于追踪和分析。
  - 日志记录应包括每个模块的执行时间和整体编译时间，确保对编译过程有全面的了解和监控。

#### 2. **代码整洁与规范**

- **代码排版**：
  - 保持代码排版整洁，采用一致的缩进方式（推荐使用4个空格），合理分隔代码块，确保逻辑清晰。
  - 每行代码的长度应适中，避免过长，提升代码的可读性。
  - 遵循PEP 8编码规范，保持代码整洁和一致性。
  - 使用有意义的变量和函数命名，便于理解和维护。

- **专业英文注释**：
  - 为每个函数或方法添加详细的英文注释，说明其作用、参数、返回值以及关键逻辑。
  - 使用类型提示（Type Hint）明确参数和返回值的类型，增强代码的可读性和静态分析能力。

- **命名规范**：
  - 变量、函数、类等命名应具备描述性，避免使用模糊或过于简短的名称，采用驼峰命名法或下划线命名法，保持一致性。
  - 避免使用过于简短或模糊的名称，确保命名能够准确反映其用途和意义。
  - 数据结构的组织应符合逻辑关系，便于理解和使用

#### 3. **错误处理与进度监控**

- **错误处理机制**：
  - 提供详细的执行过程判断，清晰展示警告和错误信息，说明错误发生的模块和具体命令。
  - 实现全面的错误处理，捕获可能的异常，提供明确的错误提示。
  - 错误信息应具备描述性，帮助用户快速定位和解决问题。
  - 确保脚本在异常情况下能够稳定运行，避免因未处理的异常导致程序崩溃。

- **美观的信息输出界面**：
  - 使用图形化或格式化的输出方式，提升错误信息的可读性和美观性。
  - 确保错误信息在界面中突出显示，便于用户注意和处理。

- **进度监控**：
  - 动态输出脚本执行状态，使用如`rich`等库优化界面输出，输出专业、详细的丰富颜色信息到终端以供用户查看执行情况和状态，并展示进度条、已完成模块数量等信息。
  - 提供直观的进度反馈，提升用户体验，帮助用户了解当前执行的进度和剩余任务。

- **日志输出**：
  - 实现不同级别的日志输出（如INFO、DEBUG、WARNING、ERROR），帮助开发者和用户快速定位问题。
  - 日志应包含时间戳、模块名称、日志级别和详细信息，确保日志的全面性和可追溯性。

#### 4. **减少代码重复**

- **高级架构与数据结构**：
  - 采用高级编程架构和数据结构技术，如工厂模式、策略模式等，减少代码冗余，提高代码的复用性。
  - 对于功能相似的变量和参数，使用数据封装和变量拼接优化，确保代码的模块化和复用性。

- **函数与方法的复用**：
  - 将重复出现的逻辑抽象为独立的函数或方法，避免在不同模块中重复编写相同的代码。
  - 确保这些复用的函数或方法具备良好的通用性和扩展性，适应不同场景的需求。

#### 5. **高级代码**

- **结构复杂的代码**：
  - 编写结构复杂且全面的代码，确保各个功能模块的正确性和稳定性。
  - 使用高级的Python特性和第三方库，如数据类（`dataclass`）等，提升代码的性能。

- **性能优化**：
  - 在功能实现过程中，注重代码的性能优化，确保脚本在处理大规模任务时具备良好的效率和响应速度。
  - 使用异步编程（`asyncio`）等技术提升脚本的并发处理能力，减少等待时间。  

- **主要使用Python**：
  - 主要使用Python完成所有功能，尽量减少Bash等外部脚本的使用，确保跨平台的兼容性和代码的可维护性。

- **代码的可扩展性**：
  - 设计功能实现时，考虑未来可能的扩展需求，确保代码结构具备良好的扩展性。
  - 通过模块化设计和接口定义，便于后续功能的添加和修改，减少对现有代码的影响。