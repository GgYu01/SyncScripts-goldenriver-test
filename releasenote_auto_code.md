# 自动填写Release Note的Python脚本开发需求文档

## 1. 引言

### 1.1 项目目标

开发一个专业、复杂、高度模块化、具有丰富可拓展性，未来扩展多功能的不使用命令行参数的复杂Python项目，用于在Linux环境下自动填写Release Note。该脚本无需使用命令行参数，主要用于开发环境调试，不涉及安全性考虑。

## 2. 总体需求概述

### 2.1 开发环境

- 操作系统：Linux
- Python 版本：3.8.10
- 执行方式：通过命令 `python3 main.py` 直接运行
- 配置管理：使用内部配置文件或模块，无需命令行参数

### 2.2 代码规范与设计原则

- 编码格式：UTF-8
- 注释：关键和复杂部分需有英文专业注释
- 模块化设计：
  - 职责单一：每个模块专注一项功能
  - 高内聚低耦合：模块内部紧密，模块间松散依赖
  - 清晰接口：模块间通过明确接口通信，便于扩展
  - 依赖注入：管理模块依赖关系，通过上下文对象传递共享配置和资源
  - 事件驱动/回调机制：处理异步任务，使用事件总线实现模块间松散耦合
  - 配置支持：通过配置文件或模块实现灵活配置，规则写入配置文件，通过配置驱动处理逻辑

## 3. 项目结构与模块说明

```
release_note_generator/
├── config/                     # 配置管理
│   ├── __init__.py
│   └── settings.py
├── core/                       # 核心功能
│   ├── __init__.py
│   ├── git_handler.py
│   ├── manifest_parser.py
│   ├── commit_processor.py
│   ├── patch_manager.py
│   └── release_note_writer.py
├── api/                        # FastAPI 接口
│   ├── __init__.py
│   ├── file_manager.py
│   ├── task_manager.py
│   └── main.py
├── tasks/                      # 任务管理
│   ├── __init__.py
│   ├── task_queue.py
│   └── task_executor.py
├── utils/                      # 工具类
│   ├── __init__.py
│   ├── logger.py
│   ├── event_bus.py
│   ├── exception_handler.py
│   ├── file_utils.py
│   └── common.py
├── main.py                     # 脚本入口
├── README.md                   # 项目说明
└── requirements.txt            # Python依赖
```

### 3.1 目录与模块功能

- config/：管理全局配置，如路径、仓库信息及 FastAPI 配置。
- core/：实现主要功能，包括 Git 操作、Manifest 解析、Commit 处理、Patch 管理及 Release Note 生成。
- api/：提供文件和任务管理的 HTTP 接口，支持文件的上传、下载、删除及任务的创建、查询、停止和删除。
- tasks/：管理任务队列，确保任务有序执行并更新状态。
- utils/：封装通用功能，如日志记录、异常处理和文件操作。
- main.py：脚本入口，协调各模块启动自动生成 Release Note 的功能。

### 3.2 模块设计与接口

#### 配置模块

- 功能：管理配置信息，提供获取接口。
- 设计：
  - 使用类或数据字典记录每个仓库的详细信息。
  - 通过 `config/settings.py` 管理所有配置项，包括路径、仓库信息、API 配置等。
  - 支持动态加载处理逻辑，根据配置文件驱动处理策略，减少硬编码。

#### Git 操作模块

- 功能：封装 Git 相关操作。
- 设计：
  - 提供统一的接口进行 Git 操作，repo和jiri工具管理的仓库应该只通过manifest获取其所有子仓库，禁止使用repo和jiri工具的命令及功能。
  - 禁止直接使用 Commit 哈希生成 Patch 文件，统一通过 git Tag 比较生成 Patch。

#### Manifest 解析模块

- 功能：解析 Manifest 文件，获取仓库列表。
- 设计：
  - 读取 XML 结构，提取 `<project>` 节点的 `name` 和 `path`。
  - 结合仓库根路径，确定子仓库的实际物理路径。
  - 示例解析：
      <project name="arm-trusted-firmware" path="arm-trusted-firmware" remote="ssh://gerrit:29418/arm-trusted-firmware" remotebranch="nebula" />
        <project name="alps/device/mediatek/config" path="device/mediatek/config"/>
    ```

#### Commit 处理模块

- 功能：获取两个 TAG 间的 Commit 信息。
- 设计：
  - 使用列表或字典存储每个 Commit 的详细信息，并关联到对应的仓库。
  - 处理特殊 Commit，通过索引或引用机制将信息连接起来，便于快速查找和汇总。

#### Release Note 生成模块

- 功能：生成并填写 Release Note 表格。
- 设计：
  - 根据 Commit 信息和 Patch 文件信息，按预定格式填充 Release Note 表格。
  - 保持数据一致性和统一，确保各模块数据自动传递和填充。

#### Patch 管理模块

- 功能：生成、识别和清理 Patch 文件。
- 设计：
  - 生成方式：在对应子 Git 仓库根路径下使用 `git format-patch <次新tag>..<最新tag>` 命令生成 Patch 文件。
  - 特殊 Commit 识别：将包含特定字符串的 Commit 归属到 `grpower` 或 `nebula` 的 Patch 文件中。
  - 清理：脚本结束后删除生成的 Patch 文件，使用绝对路径避免误删。

#### FastAPI 接口模块

- 功能：提供文件和任务管理的 HTTP 接口。
- 设计：
  - 文件管理：支持上传、下载、删除文件，路径基于仓库根目录，通过配置项管理 IP 和端口。
  - 任务管理：支持任务队列有序执行，提供查看、停止、删除任务的接口，合理标记任务状态。

#### 任务管理模块

- 功能：管理任务队列和执行状态。
- 设计：
  - 采用事件驱动机制，通过事件总线注册和发布事件，实现模块间松散耦合。

#### 日志与异常处理模块

- 功能：记录日志，处理异常。
- 设计：
  - 提供统一的错误处理机制和错误码，确保各模块在出现错误时能够按照预定方式处理和返回错误信息。

### 3.3 模块间依赖关系

- config：所有模块的基础依赖，提供配置信息。
- core：依赖 config 和 manifest_parser。
- api：依赖 core 和 tasks。
- tasks：依赖 core 和 utils。
- utils：为所有模块提供支持。

## 4. 配置与扩展

- 配置管理：通过 `config/settings.py` 管理所有配置项，支持路径、仓库信息、API 配置等。
- 扩展性：模块化设计确保未来功能扩展简便，新增功能可通过增加模块或扩展现有模块实现。通过接口隔离和依赖注入，提升代码的灵活性和可测试性。

## 5. 详细功能需求

### 5.1 获取更新的 Commit 信息

- 仓库：
  - 仓库路径：`nebula`（jiri 管理）、`grpower`、`grt`、`grt_be`、`alps`（repo 管理）、`yocto`（repo 管理）
  - Manifest 文件位置：各仓库特定路径，通过解析获取子仓库信息

- TAG 命名规范：
  - nebula 仓库：`release-spm.mt8678_mt8676_<日期>`
  - 其他仓库：`release-spm.mt8678_<日期>`
  - 日期标识：从 `~/grt` 获取最新和次新 git TAG 的日期部分，用于比较

- Manifest 文件处理：
  - 解析 `repo` 和 `jiri` 管理仓库的 Manifest 文件，提取所有子 Git 仓库的信息
  - 获取子仓库实际路径，通过 `name` 或 `path` 属性结合仓库根路径

### 5.2 生成 Release Note 表格

- 表格插入和排序：
  - 每次生成新版本时，在表格的第二行插入与本次更新 Commit 数量相对应的行
  - 每个 Commit 对应一行，多个 Commit 则插入相应行数
- 各列数据填写：
  1. A列（release 版本）：`~/grt` 最新 git TAG 名称
  2. B列（功能）：两个 git TAG 间的 Commit message 正文
  3. C列（模块）：根据更新仓库映射模块名
     - 具体对应关系：
       - `nebula`（jiri 管理）：`nebula-hyper`
       - `grpower`：`nebula-hyper`
       - `alps`（repo 管理）：`alps`
       - `yocto`（repo 管理）：`yocto`
       - `grt`：`thyp-sdk`
       - `grt_be`：`thyp-sdk-be`
  4. D列（压缩包/Patch）：
     - 正常 Commit：生成 Patch 文件的相对路径（去除`/home/nebula`）
     - 特殊 Commit：包含特定字符串的 Commit 记录在 `grpower` 或 `nebula` 的 Patch 文件中
  5. E列（示例代码/文档路径）：留空
  6. F列（提交信息）：`zircon` 和 `garnet` 仓库的最新 Commit ID
  7. G列（测试负责人 / 修改人 / MTK owner）：配置默认值
  8. H列至N列：根据配置填写或留空
  15. O列（Commit 信息）：对应 Commit 的 ID
  16. 其他列：保持空白

### 5.3 Patch 文件处理

- 生成方式：
  - 非 `nebula`、`grpower` 仓库使用 `git format-patch <TAG1>..<TAG2>` 生成
  - 禁止在 `nebula` 和 `grpower` 生成 Patch 文件

- 特殊 Commit 识别：
  - 仓库：`~/grt`，`~/alps/vendor/mediatek/proprietary/trustzone/grt`
  - 特殊字符串：
    - `] thyp-sdk: `
    - `] nebula-sdk: `
    - `] tee: `
  - 处理：
    - 特殊 Commit 不计入原仓库更新，记录在 `grpower` 或 `nebula` 的 Patch 文件中
    - 示例：
      - 如果在`alps`的子仓库中有一个Commit，其Commit message包含`] tee: `，则该Commit的Patch文件应记录在`nebula`仓库的Patch文件中，并在Release Note的对应行中填写

- **正常Commit的Patch生成**
  - 生成方式：
    - 在对应的子Git仓库根路径下，使用`git format-patch`命令在两个git TAG之间生成Patch文件
  - 注意事项：
    - 禁止直接使用Commit哈希生成Patch文件
    - 不允许保存patch文件在新建`patches`或类似的文件夹

- 清理：
  - 脚本结束后，删除生成的 Patch 文件，使用绝对路径避免误删

### 5.4 FastAPI 接口支持

- 文件管理：
  - 支持上传、下载、删除文件
  - 路径基于仓库根目录，通过配置项管理 IP 和端口
- 任务管理：
  - 启动任务执行，支持任务队列有序执行
  - 提供查看、停止、删除任务的接口，合理标记任务状态
- 事件驱动机制：
  - 创建事件总线模块，各模块通过事件总线发布和订阅事件，实现松散耦合
  - 明确定义各类事件，使模块能够根据事件进行相应处理

## 6. 特殊情况处理

### 6.1 特定仓库（nebula、alps、yocto）

- 说明：
  - 解析各自的 Manifest 文件，统一处理子 Git 仓库的 Commit 更新和 Patch 生成

### 6.2 特殊仓库处理

- 涉及仓库：
  - `~/grt`
  - `~/alps/vendor/mediatek/proprietary/trustzone/grt`

- 处理步骤：
  - 检查 Commit message 是否包含 `] thyp-sdk: `、`] nebula-sdk: ` 或 `] tee: `
  - 将包含特殊字符串的 Commit 归属到 `grpower` 或 `nebula` 的 Patch 文件和 Release Note 中

### 6.3 Manifest 文件匹配

- 解析方法：
  - 读取 XML 结构，提取 `<project>` 节点的 `name` 和 `path`
  - 结合仓库根路径，确定子仓库的实际物理路径

- 示例：
  ```xml
  <project name="alps/device/mediatek/build" path="device/mediatek/build"/>
  ```
  - 子仓库路径：`<仓库根路径>/device/mediatek/build`

- 处理步骤：
  - 遍历所有 `<project>` 节点，获取完整的子 Git 仓库列表，进行 Commit 检查和 Patch 生成

## 7. 模块设计

### 7.1 功能划分

1. 配置模块：管理配置信息，提供获取接口
2. Git 操作模块：封装 Git 相关操作
3. Manifest 解析模块：解析 Manifest 文件，获取仓库列表
4. Commit 处理模块：获取两个 git TAG 间的 Commit 信息
5. Release Note 生成模块：生成并填写 Release Note 表格
6. Patch 管理模块：生成、识别和清理 Patch 文件
7. FastAPI 接口模块：提供文件和任务管理的 HTTP 接口
8. 任务管理模块：管理任务队列和执行状态
9. 日志与异常处理模块：记录日志，处理异常

### 7.2 模块间接口与依赖

- 配置模块：为所有模块提供配置信息
- 核心模块：依赖配置和 Manifest 解析模块
- Commit 处理模块：依赖 Git 操作和 Manifest 解析模块
- Release Note 模块：依赖 Commit 处理和 Patch 管理模块
- Patch 管理模块：依赖 Git 操作和 Commit 处理模块
- FastAPI 模块：依赖任务管理和核心模块
- 任务管理模块：依赖核心和工具模块
- 日志与异常模块：为所有模块提供支持

### 7.3 设计细节与最佳实践

- 依赖注入：
  - 在初始化阶段，通过依赖注入将所需的依赖对象传递给各模块，确保模块之间的依赖关系清晰且可控。
- 接口隔离：
  - 通过定义专门的接口或抽象类，确保模块间通过接口通信，而不是直接依赖具体实现。
- 事件驱动：
  - 使用事件总线模块，各模块通过事件总线发布和订阅事件，实现松散耦合。
  - 定义各类事件，使模块能够根据事件进行相应处理。
- 统一命名规范：
  - 保持接口方法和参数命名的一致性，采用统一的命名风格（如驼峰命名或下划线命名）。
- 一致的错误处理：
  - 定义统一的错误处理机制和错误码，确保各模块在出现错误时能够按照预定方式处理和返回错误信息。
- 统一数据格式与验证：
  - 在模块间传递数据时，采用统一的数据格式（如 JSON 或自定义的序列化格式），确保数据的一致性和可解析性。
  - 在接口中加入数据验证机制，确保传递的数据符合预期格式和内容。
- 数据关联与自动填充：
  - 在 Release Note 生成模块中，将各个仓库的 Commit 和 Patch 信息汇总，按照预定的格式填充到 Release Note 表格中。
  - 设计模块间数据传递的流程，使生成 Release Note 时能够自动获取和填充所有必要的信息。
- 可测试性：
  - 通过依赖注入，方便在单元测试中替换实际依赖为模拟对象，提升测试效率和覆盖率。

## 8. 配置与扩展

- 配置管理：通过 `config/settings.py` 管理所有配置项，支持路径、仓库信息、API 配置等。
- 扩展性：
  - 模块化设计确保未来功能扩展简便，新增功能可通过增加模块或扩展现有模块实现。
  - 使用策略模式，为不同仓库类型定义不同的处理策略，根据配置动态加载相应的处理逻辑，减少硬编码。
  - 将 Commit 信息、Patch 文件信息等与对应的 Release Note 进行关联，使用索引或引用机制，将不同数据结构中的信息连接起来，便于快速查找和汇总。


### Python 代码设计与规范

#### 1. 高度模块化与配置管理

1.1 全局变量与配置

- 集中定义：
  - 在代码开头统一定义全局变量和配置项（如文件路径、仓库名称、日志设置），提升可维护性与扩展性。
  - 使用数据类（`@dataclass`）或配置文件（JSON、YAML）管理配置，避免硬编码。

- 描述性命名：
  - 全局变量和配置项采用具描述性的名称，逻辑组织数据结构，便于理解与使用。

1.2 类与功能模块

- 职责单一：
  - 使用类封装相关功能模块，如构建管理、日志处理、命令执行，确保代码结构清晰，提升内聚性。

1.3 装饰器应用

- 简化重复逻辑：
  - 利用装饰器处理日志记录、时间测量等重复性任务，提升代码可读性与复用性。

1.4 日志管理

- 独立与详细：
  - 输出独立日志文件，记录模块执行时间及整体运行时间，便于追踪与分析。

#### 2. 代码整洁与规范

2.1 排版规范

- 一致缩进与行长：
  - 统一使用4个空格缩进，控制每行代码长度适中，确保逻辑清晰可读。
  
- 适当行长：
  - 每行代码长度适中，避免过长，提升代码的可读性。

2.2 注释与文档

- 类型提示：
  - 使用类型提示（Type Hint）明确参数和返回类型，增强可读性和静态分析能力。

2.3 命名规范

- 描述性与一致性：
  - 变量、函数、类等命名具描述性，采用驼峰命名法（CamelCase）或下划线命名法（snake_case），保持一致，避免模糊名称。
  
- 避免模糊命名：
  - 避免使用过于简短或模糊的名称，确保命名能够准确反映其用途和意义。

#### 3. 错误处理与进度监控

3.1 错误处理机制

- 全面与稳定：
  - 实现全面的错误处理，提供明确描述的错误提示，确保脚本在异常情况下稳定运行，避免崩溃。

- 格式化输出：
  - 使用格式化方式显示错误信息，提升可读性和美观性，突出显示关键信息。

3.2 进度监控

- 实时与准确：
  - 实时显示模块执行状态，采用进度条和完成数量提示，确保进度信息准确、及时。

3.3 日志输出

- 多级别与详实：
  - 多级别日志，包含时间戳、模块名、级别及函数、行数等trace信息，便于问题定位与追溯。

#### 4. 代码复用与优化

4.1 架构与数据结构

- 优化与封装：
  - 采用高级编程架构和适当的数据结构，减少冗余代码，提高复用性。对相似功能的变量和参数进行封装，确保模块化。

4.2 函数与方法复用

- 抽象与通用：
  - 将重复逻辑抽象为独立函数或方法，确保其具备良好的通用性和扩展性，适应不同场景需求，避免代码重复。

#### 5. 高级代码实践

5.1 复杂结构与稳定性

- 全面模块与高级特性：
  - 编写结构完善的功能模块，确保正确性与稳定性。运用高级Python特性（如`@dataclass`、`asyncio`）和第三方库，提升性能。

5.2 减少外部依赖

- 以Python为主：
  - 主要使用Python实现功能，尽量减少Bash等外部脚本依赖，确保跨平台兼容性和代码可维护性。

5.3 可扩展性设计

- 未来扩展与模块化：
  - 设计时考虑未来扩展需求，采用高度模块化设计和明确接口定义，便于后续功能的添加和修改，减少对现有代码的影响。
